<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Callbacks vs. promises en Javascript - Jorge Sepulveda</title><meta name="description" content="Cuando hablamos de operaciones asíncronas, nos referimos a aquellas operaciones que no bloquean el hilo principal de Javascript cuando hacen alguna petición a la red o de entrada y salida del disco duro. El efecto de esto es que el código no se ejecuta siempre&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://www.jsepulveda.co/callbacks-vs-promises-en-javascript.html"><link rel="alternate" type="application/atom+xml" href="https://www.jsepulveda.co/feed.xml"><link rel="alternate" type="application/json" href="https://www.jsepulveda.co/feed.json"><meta property="og:title" content="Callbacks vs. promises en Javascript"><meta property="og:image" content="https://www.jsepulveda.co/media/website/opengraph.jpg"><meta property="og:site_name" content="Jorge Sepulveda"><meta property="og:description" content="Cuando hablamos de operaciones asíncronas, nos referimos a aquellas operaciones que no bloquean el hilo principal de Javascript cuando hacen alguna petición a la red o de entrada y salida del disco duro. El efecto de esto es que el código no se ejecuta siempre&hellip;"><meta property="og:url" content="https://www.jsepulveda.co/callbacks-vs-promises-en-javascript.html"><meta property="og:type" content="article"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@jsepulvedaco"><meta name="twitter:title" content="Callbacks vs. promises en Javascript"><meta name="twitter:description" content="Cuando hablamos de operaciones asíncronas, nos referimos a aquellas operaciones que no bloquean el hilo principal de Javascript cuando hacen alguna petición a la red o de entrada y salida del disco duro. El efecto de esto es que el código no se ejecuta siempre&hellip;"><meta name="twitter:image" content="https://www.jsepulveda.co/media/website/opengraph.jpg"><link rel="shortcut icon" href="https://www.jsepulveda.co/media/website/favicon.png" type="image/png"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link href="https://fonts.googleapis.com/css?family=Lora:400,700&amp;subset=latin-ext&amp;display=swap" rel="stylesheet"><style>:root{--body-font:'Lora',serif;--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:'Lora',serif;--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://www.jsepulveda.co/assets/css/style.css?v=3ed4467ef9d8317ede9ccf8da5087d84"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.jsepulveda.co/callbacks-vs-promises-en-javascript.html"},"headline":"Callbacks vs. promises en Javascript","datePublished":"2020-07-21T01:15","dateModified":"2020-07-21T01:16","description":"Cuando hablamos de operaciones asíncronas, nos referimos a aquellas operaciones que no bloquean el hilo principal de Javascript cuando hacen alguna petición a la red o de entrada y salida del disco duro. El efecto de esto es que el código no se ejecuta siempre&hellip;","author":{"@type":"Person","name":"Jorge"},"publisher":{"@type":"Organization","name":"Jorge"}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-113864434-1"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-113864434-1');</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://www.jsepulveda.co/">Jorge Sepulveda</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://www.jsepulveda.co/jorge-sepulveda.html" target="_self">Más información</a></li><li><a href="https://github.com/jsepulveda91" title="Github (abrir en nueva pestaña)" target="_blank" rel="nofollow noopener">Github</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://www.jsepulveda.co/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://www.jsepulveda.co/media/website/herio.jpg" srcset="https://www.jsepulveda.co/media/website/responsive/herio-xs.jpg 300w, https://www.jsepulveda.co/media/website/responsive/herio-sm.jpg 480w, https://www.jsepulveda.co/media/website/responsive/herio-md.jpg 768w, https://www.jsepulveda.co/media/website/responsive/herio-lg.jpg 1024w, https://www.jsepulveda.co/media/website/responsive/herio-xl.jpg 1360w, https://www.jsepulveda.co/media/website/responsive/herio-2xl.jpg 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" alt="Imágen del banner de la página"></figure><header class="hero__content"><div class="wrapper"><h1>Callbacks vs. promises en Javascript</h1></div></header></div><div class="wrapper post__entry"><p>Cuando hablamos de operaciones asíncronas, nos referimos a aquellas operaciones que no bloquean el hilo principal de Javascript cuando hacen alguna petición a la red o de entrada y salida del disco duro. El efecto de esto es que el código no se ejecuta siempre en secuencia (línea tras línea), sino que cuando el flujo de ejecución se encuentra con una operación asíncrona, no espera a que esta termine (no bloquea la ejecución hasta obtener la respuesta del servidor o la carga del archivo desde el disco a la memoria). En su lugar, sigue y ejecuta las siguientes líneas de código que estén más abajo. Una vez que la operación asíncrona se haya completado y se tenga una respuesta, se ejecuta el código de una función <em>callback</em>.</p><p>Las promesas o <em>Promises</em> en Javascript nos permiten trabajar con procesos asíncronos de forma más fácil y eficiente. Con ellas podemos reemplazar los <em>callbacks</em> que se le pasan a las procesos asíncronos y nos facilitan mucho las cosas cuando tenemos que ejecutar varios en secuencia.</p><p>Vamos a cargar un archivo asíncronamente desde el disco duro con Node.js</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">libros.txt</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">utf8</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">libros</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">error</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">libros</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">leyendo libros.txt</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div><p>Así es como cargamos un archivo a la memoria usando el módulo <code class="language-plaintext highlighter-rouge">fs</code> (file system) de Node.js de forma asíncrona.</p><p>El programa primero importa el módulo <code class="language-plaintext highlighter-rouge">fs</code>. Luego lo usa para leer del disco el archivo libros.txt. La última línea se ejecuta inmediatamante después y el programa imprime <code class="language-plaintext highlighter-rouge">leyendo libro.txt</code>. ¿No se suponía que la línea que imprime los libros por pantalla debería ejecutarse primero? No, pues esta es una operación asíncrona y el código no se bloquea para esperar a que el programa lea el archivo desde el disco; este sigue y una vez tenga el archivo cargado, ejecuta las líneas dentro de la función <em>callback</em>. Si hubo un error leyendo libros.txt (en caso de que el archivo no exista, por ejemplo), lanzamos un error. Si por el contrario todo salió bien, usamos <code class="language-plaintext highlighter-rouge">console.log(libros)</code> para mostrar el contenido del archivo.</p><p>En este caso usamos una función <em>callback</em> que se ejecuta una vez se haya completado la lectura del archivo. Con ella nos hacemos cargo de qué pasa si algo sale mal y también de lo que vamos a hacer una vez hayamos leído el archivo.</p><p>Sin embargo, comenzamos a tener problemas de legibilidad en nuestro código cuando tenemos que realizar otras operaciónes asíncronas una vez la primera se haya completado.</p><p>Digamos que queremos leer los archivos <code class="language-plaintext highlighter-rouge">autores.txt</code> y <code class="language-plaintext highlighter-rouge">temas.txt</code> una vez hayamos cargado <code class="language-plaintext highlighter-rouge">libros.txt</code> para imprimir el contenido de estos tres archivos por pantalla al tiempo y en el mismo orden en que los cargamos.</p><p>Como vimos anteriormente, no podemos poner al un método <code class="language-plaintext highlighter-rouge">fs.readFile()</code> por cada uno de los archivos uno debajo de la otro y esperar que se ejecuten y retornen el contenido de los archivos en secuencia, pues son operaciones asíncronas. En lugar de eso, tendríamos que poner el código para leer los otros dos archivos dentro del <em>callback</em> para leer <code class="language-plaintext highlighter-rouge">libros.txt</code>. Tendríamos que anidar uno dentro del otro.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">libros</span><span class="p">,</span> <span class="nx">autores</span><span class="p">,</span> <span class="nx">temas</span><span class="p">;</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">libros.txt</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">utf8</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">libros</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">error</span><span class="p">;</span>
  <span class="nx">libros</span> <span class="o">=</span> <span class="nx">libros</span><span class="p">;</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">autores.txt</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">utf8</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">autores</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">error</span><span class="p">;</span>
    <span class="nx">autores</span> <span class="o">=</span> <span class="nx">autores</span><span class="p">;</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">temas.txt</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">utf8</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">temas</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">error</span><span class="p">;</span>
      <span class="nx">temas</span> <span class="o">=</span> <span class="nx">temas</span><span class="p">;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">libros:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">libros</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">autores:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">autores</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">temas:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">temas</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">cargando archivos...</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div><p>Anidar nuestras solicitudes asíncronas garantiza que se ejecuten una tras otra y en el orden que nosotros definimos. Al final, en el último nivel de anidación, imprimimos el contenido de todos los archivos que cargamos.</p><p>Sin embargo, hay un problema con el uso de los <em>callbacks</em>: entre más procesos asíncronos como estos tengamos, más necesitaremos anidar unas cosas dentro de otras. ¿Qué si por ejemplo tenemos diez archivos por cargar? Tendríamos diez niveles de identación en nuestro código. Nuestro código se vería de forma piramidal. Esto da lugar a la famosa pirámide de la muerte de los <em>callbacks</em>. Además este modo de hacer las cosas impide que los procesos se realicen en paralelo, aumentanando el tiempo de espera para la carga de los archivos.</p><p>Es aquí donde las promesas or <em>Promises</em> llegan al rescate. Estas funcionan de forma similar a las promesas en la vida real. Son una promesa de que vamos a obtener un resultado de un proceso asíncrono, ya sea que este se realize satisfactoriamente o que falle. Una promesa solo puede completarse con éxito o fallar una vez. Para encargarnos de estos dos escenarios, adjuntamos un método <code class="language-plaintext highlighter-rouge">then()</code> para el primer caso y un <code class="language-plaintext highlighter-rouge">catch()</code> para el segundo a la función asíncrona que retorne una <em>Promise</em>. Esto nos evita utilizar <em>callbacks</em>. Miremos un pequeño ejemplo.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">cargarArchivo</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">archivo</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">archivo</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><p>Si la función asíncrona <code class="language-plaintext highlighter-rouge">cargarArchivo()</code> retorna una promesa, podemos adjuntar un <code class="language-plaintext highlighter-rouge">then()</code> a esta para procesar la resolución exitosa de la promesa (cargamos el archivo con éxito). Adjuntamos un <code class="language-plaintext highlighter-rouge">catch()</code> para <em>capturar</em> el error y hacer algo con él en caso de que algo haya salido mal (en este caso simplemente lo imprimimos por pantalla).</p><p>¿Y por qué es importante esto? Las promesas nos evitan usar <em>callbacks</em> y tener que anidar uno dentro del otro para realizar varios procesos asíncronos que se van a ejecutar en secuencia. Cada <code class="language-plaintext highlighter-rouge">then()</code> retorna a su vez una promesa a la cual le podemos adjuntar otro <code class="language-plaintext highlighter-rouge">then()</code>. Podemos encadenar varios procesos asíncronos uno tras otro y ejecutarlos como si fueran síncronos. Veamos cómo se vería la carga de tres archivos con <em>Promises</em> en lugar de <em>callbacks</em>.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">libros</span><span class="p">,</span> <span class="nx">autores</span><span class="p">,</span> <span class="nx">temas</span><span class="p">;</span>

<span class="nx">cargarLibros</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">books</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">libros</span> <span class="o">=</span> <span class="nx">books</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">cargarAutores</span><span class="p">();</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">authors</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">autores</span> <span class="o">=</span> <span class="nx">authors</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">cargarTemas</span><span class="p">();</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">topics</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">temas</span> <span class="o">=</span> <span class="nx">topics</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">libros:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">libros</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">autores:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">autores</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">temas:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">temas</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hubo un error cargando algún archivo</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><p>¿Sí ves cuán legible es el código? Ya no tenemos que hacer anidaciones y terminar con una pirámide de la muerte de <em>callbacks</em>. Para que esto se pueda hacer así, las funciones <code class="language-plaintext highlighter-rouge">cargarLibros()</code>, <code class="language-plaintext highlighter-rouge">cargarAutores()</code> y <code class="language-plaintext highlighter-rouge">cargarTemas()</code> deben retornar cada una una <em>Promise</em>. cuando la promesa de la primera función termina de cargar los libros, el primer <code class="language-plaintext highlighter-rouge">then()</code> captura el resultado y retorna la siguiente función para cargar los autores. Una vez tenemos cargado el archivo de autores, en el siguiene <code class="language-plaintext highlighter-rouge">then()</code> retornamos función para cargar los temas. Una vez se haya cargado este último archivo, procedemos a imprimir las variables que fuimos asignando para libros, autores y temas. Como ves, el código se ejecuta secuencialmente como si fuera síncrono. El último método que adjuntamos a la cadena de promesas (<code class="language-plaintext highlighter-rouge">catch()</code>) captura el error que haya ocurrido en cualquier eslabón de la cadena de <code class="language-plaintext highlighter-rouge">then()s</code>. Si la carga de aĺguno de los archivos falla, el error es capturado por el <code class="language-plaintext highlighter-rouge">catch()</code> y desde allí lo podemos manejar (en nuestro caso, solo imprimimos en pantalla que hubo un error).</p><p>Ahora bien, ¿es posible entonces adjuntar un .then() al método <code class="language-plaintext highlighter-rouge">fs.readFile()</code> y refactorizar el mismo código usando prómises, como hicimos en el ejemplo anterior? Por desgracia, no es así de fácil: este método no retorna promesas. No obstante, podemos crear una función que lea archivos desde el disco duro usando este mismo método y haciendo que retorne une una <em>Promise</em>.</p><p>A continuación vamos a ver cómo podemos usar el constructor del patrón <em>Promise</em> para instanciar una nueva promesa y hacer que nuestra función de leer archivos desde el disco retorne una <em>Promise</em> para poderle adjuntar los métodos <code class="language-plaintext highlighter-rouge">then()</code> y <code class="language-plaintext highlighter-rouge">catch()</code>.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">libros</span><span class="p">,</span> <span class="nx">autores</span><span class="p">,</span> <span class="nx">temas</span><span class="p">;</span>

<span class="c1">// creamos una función asíncrona que retorne una Promise</span>
<span class="kd">function</span> <span class="nx">cargarArchivo</span><span class="p">(</span><span class="nx">archivo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">archivo</span><span class="p">,</span> <span class="dl">'</span><span class="s1">utf8</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">datos</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">datos</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="c1">// ahora sí podemos usar .then() y .catch()</span>
<span class="nx">cargarArchivo</span><span class="p">(</span><span class="dl">'</span><span class="s1">libros.txt</span><span class="dl">'</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">books</span> <span class="o">=&gt;</span> <span class="p">{</span> 
  <span class="nx">libros</span> <span class="o">=</span> <span class="nx">books</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">cargarArchivo</span><span class="p">(</span><span class="dl">'</span><span class="s1">autores.txt</span><span class="dl">'</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">authors</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">autores</span> <span class="o">=</span> <span class="nx">authors</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">cargarArchivo</span><span class="p">(</span><span class="dl">'</span><span class="s1">temas.txt</span><span class="dl">'</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">topics</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">temas</span> <span class="o">=</span> <span class="nx">topics</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">libros:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">libros</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">autores:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">autores</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">temas:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">temas</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hubo un error cargando algún archivo</span><span class="dl">'</span><span class="p">)</span>
<span class="p">});</span> <span class="c1">// si ocurre algún error cargando cualquier archivo</span>
</code></pre></div></div><p>El constructor de <em>Promise</em> recibe una función anónima con dos argumentos: <code class="language-plaintext highlighter-rouge">resolve</code> y <code class="language-plaintext highlighter-rouge">reject</code>. El primero resuelve la promesa si su resultado fue exitoso (retornandola para ser procesada posteriormente por un <code class="language-plaintext highlighter-rouge">then</code>), mientras que el segundo la rechaza si hubo un error (en cuyo caso es recolectado por el <code class="language-plaintext highlighter-rouge">catch</code>).</p><p>Lo aprendido hasta ahora nos muestra cómo podemos refactorizar nuestro código para que sea más legible. Sin embargo, hay una forma de hacerlo también más eficiente.</p><p>Las <em>Promises</em> tienen un método llamado <code class="language-plaintext highlighter-rouge">all</code> que permite resolverlas en paralelo. Consideremos el siguiente código para ilustrar su uso.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// definición de la función cargarArchivo()</span>
<span class="c1">// y declaración de las variables</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
  <span class="nx">cargarArchivo</span><span class="p">(</span><span class="dl">'</span><span class="s1">libros.txt</span><span class="dl">'</span><span class="p">),</span>
  <span class="nx">cargarArchivo</span><span class="p">(</span><span class="dl">'</span><span class="s1">autores.txt</span><span class="dl">'</span><span class="p">),</span>
  <span class="nx">cargarArchivo</span><span class="p">(</span><span class="dl">'</span><span class="s1">temas.txt</span><span class="dl">'</span><span class="p">)</span>
<span class="p">])</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">archivos</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// retorna un array con las promesas resueltas</span>
  <span class="nx">libros</span> <span class="o">=</span> <span class="nx">archivos</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="nx">autores</span> <span class="o">=</span> <span class="nx">archivos</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="nx">temas</span> <span class="o">=</span> <span class="nx">archivos</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hubo un error cargando algún archivo</span><span class="dl">'</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div></div><p>Este método recibe un array con las <em>Promises</em> y las resuelve todas en paralelo en el mismo orden. Retorna un array con la lista de los resultados una vez que <strong>todas las Promises hayan sido resueltas</strong>. Si ocurre un error en <strong>alguna</strong> de estas, <code class="language-plaintext highlighter-rouge">Promise.all()</code> va a rechazar las promesas y el error será capturado por <code class="language-plaintext highlighter-rouge">catch()</code>, sin importar si las demás ya resolvieron. Es buena práctica que siempre pongas un catch() al final para manejar los errores.</p><p>Espero que esta introducción (un poco larga) a las <em>Promises</em> como alternativa a los clásicos <em>callbacks</em> haya sido lo suficientemente clara y concisa. Si quieres profundizar más sobre el funcionamiento de este patrón junto con sus especificaciones y usos, busca en Google… No mentiras: la documentación de <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise/all" target="_blank" rel="noopener">Mozilla.org</a> ofrece una buena gía al respecto. También la de <a href="https://developers.google.com/web/fundamentals/primers/promises?hl=es" target="_blank" rel="noopener">Google developers</a>.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on jul. 21, 2020</p><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.jsepulveda.co%2Fcallbacks-vs-promises-en-javascript.html" class="js-share facebook" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/share?url=https%3A%2F%2Fwww.jsepulveda.co%2Fcallbacks-vs-promises-en-javascript.html&amp;via=jsepulvedaco&amp;text=Callbacks%20vs.%20promises%20en%20Javascript" class="js-share twitter" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="http://www.linkedin.com/shareArticle?url=https%3A%2F%2Fwww.jsepulveda.co%2Fcallbacks-vs-promises-en-javascript.html&amp;title=Callbacks%20vs.%20promises%20en%20Javascript" class="js-share linkedin" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span> </a><a href="https://api.whatsapp.com/send?text=Callbacks%20vs.%20promises%20en%20Javascript https%3A%2F%2Fwww.jsepulveda.co%2Fcallbacks-vs-promises-en-javascript.html" class="js-share whatsapp" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#whatsapp"/></svg> <span>WhatsApp</span></a></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://www.jsepulveda.co/como-aprender-ingles-efectivamente.html" class="invert post__nav-link" rel="prev"><span>Previous</span> Cómo aprender inglés efectivamente</a></div><div class="post__nav-next"><a href="https://www.jsepulveda.co/metodos-de-iteracion-sobre-arrays-en-javascript.html" class="invert post__nav-link" rel="next"><span>Next</span> Métodos de iteración sobre arrays en Javascript </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2020-07-21T01:19" class="feed__date">jul. 21, 2020</time></div><h3 class="h1"><a href="https://www.jsepulveda.co/metodos-de-iteracion-sobre-arrays-en-javascript.html" class="invert">Métodos de iteración sobre arrays en Javascript</a></h3></article></div></div><div class="post__comments"><div class="wrapper"><h2 class="h5">Comments</h2><div id="disqus_thread"></div><script>var disqus_config = function () {
                       this.page.url = 'https://www.jsepulveda.co/callbacks-vs-promises-en-javascript.html';
               		this.page.identifier = '3';
                   };
               
                   var disqus_loaded = false;
               
                   function publiiLoadDisqus() {
                       if(disqus_loaded) {
                           return false;
                       }
               
                       var top = document.getElementById('disqus_thread').offsetTop;
               
                       if (!disqus_loaded && (window.scrollY || window.pageYOffset) + window.innerHeight > top) {
                           disqus_loaded = true;
               
                           (function () {
                               var d = document, s = d.createElement('script');
                               s.src = 'https://jorgesepulveda-com-co.disqus.com/embed.js';
                               s.setAttribute('data-timestamp', +new Date());
                               (d.head || d.body).appendChild(s);
                           })();
                       }
                   }
               
                   publiiLoadDisqus();
               
                   window.onscroll = function() {
                       publiiLoadDisqus();
                   };</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noreferrer">comments powered by Disqus.</a></noscript></div></div></main><footer class="footer"><div class="footer__social"><a href="https://twitter.com/JsepulvedaCo" aria-label="Twitter"><svg><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#twitter"/></svg> </a><a href="https://www.linkedin.com/in/jsepulveda91/" aria-label="LinkedIn"><svg><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#linkedin"/></svg></a></div><div class="footer__copyright"><p>@ 2020 Jorge Sepulveda. Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii Static CMS</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://www.jsepulveda.co/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'overlay',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://www.jsepulveda.co/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>